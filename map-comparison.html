<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Joe Thomas | On the Implementation of Map</title>
    <link rel="shortcut icon" type="image/png" href="https://jsthomas.github.io/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="https://jsthomas.github.io/favicon.ico">
    <link href="https://jsthomas.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Joe Thomas Full Atom Feed" />
    <link href="https://jsthomas.github.io/feeds/ocaml-profiling.atom.xml" type="application/atom+xml" rel="alternate" title="Joe Thomas Categories Atom Feed" />
    <link rel="stylesheet" href="https://jsthomas.github.io/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="https://jsthomas.github.io/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://jsthomas.github.io/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Joe Thomas" />

</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="https://jsthomas.github.io/">About</a></li>
                <li><a href="https://jsthomas.github.io/pages/papers.html">Papers</a></li>
                <li><a href="https://jsthomas.github.io/pages/projects.html">Projects</a></li>
                <li><a href="https://jsthomas.github.io/pages/talks.html">Talks</a></li>
                <li><a href="https://github.com/jsthomas/">GitHub</a></li>
                <li><a href="https://www.linkedin.com/in/joseph-thomas-539bb969/">LinkedIn</a></li>
                <li><a href="https://jsthomas.github.io/blog">Blog</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="https://jsthomas.github.io/">Joe Thomas</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Jun 06, 2017</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://jsthomas.github.io/map-comparison.html" rel="bookmark" title="Permanent Link to &quot;On the Implementation of Map&quot;">On the Implementation of Map</a>
                </h2>

                
                

                <p><code>Map</code> is one of the first higher-order functions I remember
encountering when I learned some rudimentary functional programming
topics as an undergraduate. More recently I began learning OCaml. The
<code>map</code>
<a href="https://github.com/ocaml/ocaml/blob/2691c40f2ff9bc34912db39bc1f17045c9241473/stdlib/list.ml#L80-L82">implementation</a>
I found in the standard library was the textbook definition I was
expecting</p>
<div class="highlight"><pre><span></span>let rec map f = function
    [] -&gt; []
  | a::l -&gt; let r = f a in r :: map f l
</pre></div>
<p>but I was surprised to learn there are actually several
implementations of <code>map</code>, with different characteristics:</p>
<ul>
<li>
<p>The implementation above (which I'll refer to as <code>stdlib</code>) is not
  <em>tail recursive</em>, so it takes space on the stack proportional to the
  length of the input list. For long enough lists, this causes a
  stack overflow.</p>
</li>
<li>
<p>One can instead write a tail recursive version that takes up
  constant space on the stack, at the cost of an additional list
  traversal.</p>
</li>
<li>
<p>The package <code>batteries</code> features a more imperative
  <a href="https://github.com/ocaml-batteries-team/batteries-included/blob/c10c65a203a7590b15b9a370f66e8c2884817428/src/batList.mlv#L163-L173">implementation</a>.</p>
</li>
<li>
<p><a href="https://github.com/janestreet/base/blob/f10483e957206dc6b656a28ffec667d8b068c149/src/list.ml#L311-L345"><code>base</code></a>
  and
  <a href="https://github.com/c-cube/ocaml-containers/blob/d659ba677e3dbd95430f59b3794ac2f2a5677d61/src/core/CCList.ml#L20-L37"><code>containers</code></a>
  use special cases to treat very short lists (similar to loop
  unrolling) and revert to tail recursion for very long lists.</p>
</li>
</ul>
<p>that handles very short lists separately and defaults to tail
recursion for long lists.</p>
<p>Given all of these different ways to <code>map</code>, I wanted to know:</p>
<ul>
<li>
<p>Which version is the fastest?</p>
</li>
<li>
<p>How much speed does one lose using the safer tail recursive version?</p>
</li>
</ul>
<p>Part of my motivation to write this post arose from
<a href="https://github.com/ocsigen/lwt/pull/347">this discussion</a> of a pull
request, which proposes the default <code>map</code> implementation in <code>lwt</code>
should be tail recursive. After reading all of the comments, I wanted
to develop some experiments that would convince me whether a tail
recursive <code>map</code> really is too slow to be used.</p>
<h1>Experimental Setup</h1>
<p>In 2014, Jane Street introduced a
<a href="https://github.com/janestreet/core_bench">library</a> for
microbenchmarking called <code>core_bench</code>. As they explain
<a href="https://blogs.janestreet.com/core_bench-micro-benchmarking-for-ocaml/">on their blog</a>,
<code>core_bench</code> is intended to measure the performance of small pieces of
OCaml code. This library helps developers to better understand the
cost of individual operations, like <code>map</code>.</p>
<p>There are a couple benefits to measuring map implementations with
<code>core_bench</code>.</p>
<ol>
<li>
<p>The library makes it easy to track both time and use of the heap.</p>
</li>
<li>
<p>Once you specify your test, <code>core_bench</code> automatically provides
   many <a href="https://github.com/janestreet/core_bench/wiki/Getting-Started-with-Core_bench">command line
   options</a>
   to help you present your test data in different ways.</p>
</li>
<li>
<p>The library uses statistical techniques (bootstrapping and linear
   regression) to reduce many runs worth of data to a small number of
   meaningful performance metrics that account for the amortized cost
   of garbage collection and error introduced by system activity.</p>
</li>
</ol>
<p>I wrote
<a href="https://github.com/jsthomas/ocaml-analysis/blob/master/map/maptest.ml">this program</a>
to compare performance between the five implementations I described
above. Specifically:</p>
<ul>
<li>I tested each algorithm against lists of lengths <span class="math">\(N=10^2, 10^3,
  10^4\)</span> and <span class="math">\(10^5\)</span>. On my system, <span class="math">\(N=10^5\)</span> was the highest power of 10
  for which the <code>stdlib</code> implementation did not fail due to a stack
  overflow.</li>
<li>Each list consisted of integer elements (all 0), and the function
  mapped onto the list simply added one to each element.</li>
<li>I ran these tests on a Lenovo X220, Intel Core i5-2520M CPU (2.50GHz ×
  4 cores), with 4GB RAM.</li>
<li>I used the OCaml 4.03.0 compiler, and compiled to native code
  without using <code>flambda</code>. (<a href="https://github.com/jsthomas/ocaml-analysis/blob/master/map/makefile">This
  makefile</a>
  gives the full specifications.)</li>
</ul>
<h1>Results</h1>
<p>For each list size, <code>core_bench</code> produces a table with several metrics besides time:</p>
<ul>
<li><code>mWd</code> : Words allocated on the minor heap.</li>
<li><code>mjWd</code> : Words allocated on the major heap.</li>
<li><code>Prom</code> : Words promoted from minor to major heap.</li>
</ul>
<p>The library also allows us to produce 95% confidence intervals and
<span class="math">\(R^2\)</span> values for the time estimates.</p>
<p><strong>Map Benchmark, N = 100</strong></p>
<div class="highlight"><pre><span></span>┌────────────┬──────────┬──────────┬───────────────┬─────────┬──────────┬──────────┬────────────┐
│ Name       │ Time R^2 │ Time/Run │        95% ci │ mWd/Run │ mjWd/Run │ Prom/Run │ Percentage │
├────────────┼──────────┼──────────┼───────────────┼─────────┼──────────┼──────────┼────────────┤
│ tail rec.  │     1.00 │ 732.23ns │ -0.21% +0.23% │ 609.01w │    0.53w │    0.53w │    100.00% │
│ containers │     1.00 │ 427.59ns │ -0.12% +0.13% │ 304.03w │    0.17w │    0.17w │     58.40% │
│ batteries  │     1.00 │ 578.28ns │ -0.14% +0.15% │ 309.01w │    0.35w │    0.35w │     78.98% │
│ base       │     1.00 │ 419.16ns │ -0.21% +0.27% │ 304.03w │    0.16w │    0.16w │     57.24% │
│ stdlib     │     1.00 │ 614.10ns │ -0.24% +0.26% │ 304.01w │    0.17w │    0.17w │     83.87% │
└────────────┴──────────┴──────────┴───────────────┴─────────┴──────────┴──────────┴────────────┘
</pre></div>
<p><strong>Map Benchmark, N = 1000</strong></p>
<div class="highlight"><pre><span></span>┌────────────┬──────────┬──────────┬───────────────┬─────────┬──────────┬──────────┬────────────┐
│ Name       │ Time R^2 │ Time/Run │        95% CI │ mWd/Run │ mjWd/Run │ Prom/Run │ Percentage │
├────────────┼──────────┼──────────┼───────────────┼─────────┼──────────┼──────────┼────────────┤
│ tail rec.  │     1.00 │   8.82us │ -0.22% +0.27% │  6.01kw │   52.09w │   52.09w │    100.00% │
│ containers │     1.00 │   5.08us │ -0.22% +0.26% │  3.00kw │   17.26w │   17.26w │     57.62% │
│ batteries  │     0.98 │   6.79us │ -1.45% +1.88% │  3.01kw │   34.71w │   34.71w │     76.96% │
│ base       │     1.00 │   4.96us │ -0.18% +0.19% │  3.00kw │   17.08w │   17.08w │     56.27% │
│ stdlib     │     0.99 │   6.87us │ -0.99% +1.36% │  3.00kw │   17.25w │   17.25w │     77.84% │
└────────────┴──────────┴──────────┴───────────────┴─────────┴──────────┴──────────┴────────────┘
</pre></div>
<p><strong>Map Benchmark, N = 10,000</strong></p>
<div class="highlight"><pre><span></span>┌────────────┬──────────┬──────────┬───────────────┬─────────┬──────────┬──────────┬────────────┐
│ Name       │ Time R^2 │ Time/Run │        95% CI │ mWd/Run │ mjWd/Run │ Prom/Run │ Percentage │
├────────────┼──────────┼──────────┼───────────────┼─────────┼──────────┼──────────┼────────────┤
│ tail rec.  │     1.00 │ 200.15us │ -0.27% +0.29% │ 60.01kw │   5.40kw │   5.40kw │    100.00% │
│ containers │     0.98 │ 148.02us │ -1.51% +1.81% │ 48.01kw │   3.05kw │   3.05kw │     73.95% │
│ batteries  │     1.00 │ 134.00us │ -0.46% +0.48% │ 30.01kw │   3.62kw │   3.62kw │     66.95% │
│ base       │     1.00 │ 132.76us │ -0.53% +0.58% │ 44.98kw │   2.66kw │   2.66kw │     66.33% │
│ stdlib     │     1.00 │ 120.09us │ -0.43% +0.48% │ 30.00kw │   1.79kw │   1.79kw │     60.00% │
└────────────┴──────────┴──────────┴───────────────┴─────────┴──────────┴──────────┴────────────┘
</pre></div>
<p><strong>Map Benchmark, N = 100,000</strong></p>
<div class="highlight"><pre><span></span>┌────────────┬──────────┬──────────┬───────────────┬──────────┬──────────┬──────────┬────────────┐
│ Name       │ Time R^2 │ Time/Run │        95% CI │  mWd/Run │ mjWd/Run │ Prom/Run │ Percentage │
├────────────┼──────────┼──────────┼───────────────┼──────────┼──────────┼──────────┼────────────┤
│ tail rec.  │     0.99 │  10.83ms │ -1.81% +1.61% │ 600.02kw │ 414.00kw │ 414.00kw │     99.85% │
│ containers │     0.99 │  10.83ms │ -1.73% +1.97% │ 588.02kw │ 405.39kw │ 405.39kw │     99.84% │
│ batteries  │     0.99 │   7.13ms │ -1.13% +1.05% │ 300.02kw │ 300.35kw │ 300.35kw │     65.77% │
│ base       │     0.99 │  10.85ms │ -1.93% +1.92% │ 584.99kw │ 399.21kw │ 399.21kw │    100.00% │
│ stdlib     │     0.99 │   6.57ms │ -1.24% +1.19% │ 300.01kw │ 173.43kw │ 173.43kw │     60.56% │
└────────────┴──────────┴──────────┴───────────────┴──────────┴──────────┴──────────┴────────────┘
</pre></div>
<p>I noticed several things about in the data above:</p>
<ul>
<li>
<p>The tail recursive implementation is consistently slowest. (In the
  final test <code>base</code>, <code>containers</code> and the tail recursive version all
  appear to be equally slow.) This makes sense, because <code>base</code> and
  <code>containers</code> default to a tail recursive implementation for long
  lists.</p>
</li>
<li>
<p>For short lists, <code>base</code> and <code>containers</code> are quite fast, possibly
  due to the "loop unrolling" (special cases for short lists) in their
  definitions.</p>
</li>
<li>
<p>We can see from the <code>mWd</code> and <code>mjWd</code> columns that the tail recursive
  implementation uses the most heap space, as we would expect.</p>
</li>
<li>
<p>As we increase the size of the list, <code>stdlib</code> gets faster relative
  to <code>stdlib</code> (from 83% to 60%); I suspect this can be attributed to
  the cost of garbage collections.</p>
</li>
<li>
<p>The <code>batteries</code> implementation is not the most performant for short
  lists, but it's performance is pretty close to that of <code>stdlib</code> for
  the longest lists tested.</p>
</li>
</ul>
<h1>Conclusions</h1>
<p>The data above suggests two findings:</p>
<ol>
<li>
<p>The stack-based standard library implementation of <code>map</code> is faster
   than the naive tail recursive implementation, taking about 60-84%
   of the time to do the same work depending on the size of the list.</p>
</li>
<li>
<p>There is a benefit to using a more complicated "hybrid"
   implementation that treats very short lists with special cases, and
   reverts to tail recursion for long lists.</p>
</li>
</ol>
<p>We can see in the <span class="math">\(N = 100\)</span> data that the <code>base</code> and <code>containers</code>
implementations are significantly faster than <code>stdlib</code>, but unlike
<code>stdlib</code> they cannot cause a stack overflow. Given that these
implementations are safer <em>and</em> faster for short lists, it seems
reasonable to prefer them.</p>
<h1>Discussion</h1>
<p>A follow up question to this analysis, in the context of the
discussion of <code>Lwt.map</code> is: "How significant is the cost of <code>map</code>
compared to other operations?" To partially address this, I wrote
<a href="https://github.com/jsthomas/ocaml-analysis/blob/master/map/bufftest.ml">another program</a>
that measures how long it takes to write 4096 bytes to a Unix pipe
using <code>Lwt.write</code>, and then read it back using <code>Lwt.read</code>. Using
<code>core_bench</code>, I found:</p>
<p><strong>Unix Pipe Write Benchmark</strong></p>
<div class="highlight"><pre><span></span>┌─────────┬──────────┬───────────────┬─────────┬────────────┐
│Time R^2 │ Time/Run │          95ci │ mWd/Run │ Percentage │
├─────────┼──────────┼───────────────┼─────────┼────────────┤
│    1.00 │ 893.33ns │ -0.16% +0.18% │  56.00w │    100.00% │
└─────────┴──────────┴───────────────┴─────────┴────────────┘
</pre></div>
<p>It seems reasonable to estimate that <code>Lwt.map</code> would primarily be
applied to IO operations like the ones in this experiment. In that
case, the data suggest the cost per element of applying the slowest
map implementation (<code>tail rec.</code>) is about 0.82% of the cost of one 4KB
read/write operation on a unix pipe. In the context of <code>Lwt</code>, it seems
reasonable to conclude the implementation of <code>map</code> isn't a significant
concern; the real cost is performing IO. In light of that, it seems
preferable to use an implementation that cannot fail due to a stack
overflow.</p>
<p>A second question that might be asked about this analysis is: "Was it
really necessary to introduce the added complexity of <code>core_bench</code> to
measure the performance of <code>map</code>?" For example, one might set up a
performance test with just successive calls to <code>Time.now</code> or <code>Unix.gettimeofday</code>. In an
earlier draft of this article, I tried such an
<a href="https://github.com/jsthomas/ocaml-analysis/blob/master/map/profile.ml">approach</a>,
producing some misleading data. In that test, I did a full garbage
collection in between runs (applications of <code>map</code>), which suppressed
that (nontrivial) cost and made the tail recursive implementation
appear quite fast. In my view, <code>core_bench</code> does a much better job of
accounting for the cost of garbage collection by varying the number of
test runs performed in a row, and then establishing a trend (with
linear regression) that can be used to account for the amortized cost
of garbage collection per run.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://jsthomas.github.io/map-comparison.html">posted at 00:00</a>
                    &nbsp;&middot;&nbsp;<a href="https://jsthomas.github.io/category/ocaml-profiling.html" rel="tag">OCaml, Profiling</a>
                </div>
            </article>
            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
                &middot;
                <a href="https://jsthomas.github.io/feeds/all.atom.xml" rel="alternate">Atom Feed</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-50587049-3");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>